# Завдання 1

## Умова

Запустіть Docker-контейнер і поекспериментуйте з максимальним лімітом ресурсів відкритих файлів. Для цього виконайте команди у вказаному порядку:

```bash
$ ulimit -n
$ ulimit -aS | grep "open files"
$ ulimit -aH | grep "open files"
$ ulimit -n 3000
$ ulimit -aS | grep "open files"
$ ulimit -aH | grep "open files"
$ ulimit -n 3001
$ ulimit -n 2000
$ ulimit -n
$ ulimit -aS | grep "open files"
$ ulimit -aH | grep "open files"
$ ulimit -n 3000
```

Як наступне вправу, повторіть перераховані команди з root-правами.

## Виконання

Для початку запустимо контейнер. Для цього завантажимо `Docker` та підключимо посилання для образів. Тепер пропишемо команду для запуску контейнера:

```bash
docker run -it --rm ubuntu bash
```

Після того як контейнер запустився, вводимо по черзі надані команди.

### Результат введення команд

![](task1/task1.png)

Як ми бачимо, зі звичайними правами ми можемо знижувати ліміт, проте підвищувати - ні.

Тепер повторимо виконані дії з `root`-правами. Для цього вийдемо з першого контейнера командою `exit`, та запустимо новий контейнер:

```bash
docker run -it --rm --privileged ubuntu bash
```

Тепер вводимо дані команди.

### Результат введення команд з root-правами

![](task1/task1_root.png)

Як ми бачимо, з `root`-правами ми можемо не тільки знижувати а й підвищувати ліміт. Для закриття контейнера використаємо команду `exit`.

# Завдання 2

## Умова

У Docker-контейнері встановіть утиліту perf(1). Поекспериментуйте з досягненням процесом встановленого ліміту.

## Пояснення

### Скрипт

```bash
#!/bin/bash

counter=0
while true; do
sleep 2 &
counter=$( (counter + 1))
echo "Created $counter processes"

done

```

### Результат використання команди `perf top`

![](task2/task2.png)

# Завдання 3

## Умова

Напишіть програму, що імітує кидання шестигранного кубика. Імітуйте кидки, результати записуйте у файл, для якого попередньо встановлено обмеження на його максимальний розмір (max file size). Коректно обробіть ситуацію перевищення ліміту.

## Виконання

### Код програми

```c
#define FILENAME "dice_results.txt"
#define MAX_FILE_SIZE 128

void roll_dice_and_write() {
    FILE *file;
    struct stat file_stat;

    int dice_roll = rand() % 6 + 1;

    if (stat(FILENAME, &file_stat) == 0 && file_stat.st_size >= MAX_FILE_SIZE) {
        printf("File exceeded %d bites, clean it...\n", MAX_FILE_SIZE);
        file = fopen(FILENAME, "w");
    } else {
        file = fopen(FILENAME, "a");
    }

    if (file == NULL) {
        perror("Error: can not open file");
        exit(EXIT_FAILURE);
    }

    fprintf(file, "Rolling: %d\n", dice_roll);
    fclose(file);

    printf("Dice roll: %d (written to file)\n", dice_roll);
}

int main() {
    srand(time(NULL));
    char choice;

    do {
        roll_dice_and_write();
        printf("Throw again? (y/n): ");
        scanf(" %c", &choice);
    } while (choice == 'y' || choice == 'Y');

    printf("The game is over. The results are saved to %s\n", FILENAME);
    return 0;
}
```

Програма імітує кидання шестигранного кубика і записує результати у файл. Вона працює наступним чином: після запуску генерується випадкове число від 1 до 6, яке імітує результат кидка кубика. Кожен результат записується у текстовий файл, що знаходиться в поточній директорії під назвою `dice_results.txt`. Якщо розмір файлу перевищує встановлене обмеження, програма очищає файл і починає записувати нові результати знову.

Програма використовує нескінченний цикл, який генерує новий кидок кубика кожну секунду. Після кожного кидка вона запитує користувача, чи хоче він продовжити гру. Якщо користувач вводить "y" або "Y", програма кидає кубик ще раз. Якщо ж вводиться будь-яка інша літера, програма завершить свою роботу.

### Результат запуску програми

![](task3/task3_result.png)

### Файл dice_results.txt після запуску програми

![](task3/task3_result_file.png)

Крім того, програма перевіряє розмір файлу після кожного запису. Якщо розмір файлу досягає встановленого ліміту в 128 байт, програма очищає файл, щоб продовжити запис. Це дозволяє забезпечити, що файл не перевищує заданий розмір і що в ньому завжди буде лише обмежена кількість результатів.

Таким чином, програма надає користувачеві можливість взаємодіяти з нею, вибираючи, скільки разів вона має продовжити кидати кубик, і дозволяє зберігати результати кожного кидка у файлі.

### Результат запуску програми з переповненням 

![](task3/task3_owerflow.png)

### Файл dice_results.txt після запуску програми з переповненням

![](task3/task3_owerflow_file.png)

# Завдання 4

## Умова

Напишіть програму, що імітує лотерею, вибираючи 7 різних цілих чисел у діапазоні від 1 до 49 і ще 6 з 36. Встановіть обмеження на час ЦП (max CPU time) і генеруйте результати вибору чисел (7 із 49, 6 із 36). Обробіть ситуацію, коли ліміт ресурсу вичерпано.

## Виконання

# Завдання 5

## Умова

Напишіть програму для копіювання одного іменованого файлу в інший. Імена файлів передаються у вигляді аргументів.

Програма має:
- перевіряти, чи передано два аргументи, інакше виводити "Program need two arguments";
- перевіряти доступність першого файлу для читання, інакше виводити "Cannot open file .... for reading";
- перевіряти доступність другого файлу для запису, інакше виводити "Cannot open file .... for writing";
- обробляти ситуацію перевищення обмеження на розмір файлу.


## Виконання

# Завдання 6

## Умова

Напишіть програму, що демонструє використання обмеження (max stack segment size). Підказка: рекурсивна програма активно використовує стек.

## Виконання

# Завдання 7 (варіант 20)

## Умова

Написати програму, яка тестує вплив ulimit -r на пріоритети процесів.

## Виконання

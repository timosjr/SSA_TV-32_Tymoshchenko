# Завдання 1

## Умова

Використайте popen(), щоб передати вивід команди rwho (команда UNIX) до more (команда UNIX) у програмі на C.

## Виконання

### [Код програми](task1/task1.c) 

### Пояснення

У цьому коді виконується команда `rwho`, яка виводить список підключених користувачів у системі, і передає її вивід до команди `more`, яка дозволяє переглядати текст в терміналі посторінково. У нашому випадку вивід пустий, оскільки немає користувачів у системі. 

### Результат запуску програми

![](task1/task1.png)

# Завдання 2

## Умова

Напишіть програму мовою C, яка імітує команду ls -l в UNIX — виводить список усіх файлів у поточному каталозі та перелічує права доступу тощо.
 (Варіант вирішення, що просто виконує ls -l із вашої програми, — не підходить.)

## Виконання

### [Код програми](task2/task2.c) 

### Пояснення

У цій програмі імітується поведінка команди `ls -l`. Програма відкриває поточний катало, перебирає всі файли та для кожного отримує інформацію за допомогою `lstat()`.

Для кожного файлу виводяться тип файлу та права доступу (через функцію `print_permissions`), кількість жорстких посилань, ім’я власника, групи, розмір файлу, час останньої модифікації у форматі місяць день час і ім’я файлу.

Програма працює без виклику зовнішніх команд, отримуючи інформацію безпосередньо через системні виклики, що відповідає оригінальному `ls -l`.

### Результат запуску програми

![](task2/task2.png)

# Завдання 3

## Умова

Напишіть програму, яка друкує рядки з файлу, що містять слово, передане як аргумент програми (проста версія утиліти grep в UNIX).

## Виконання

### [Код програми](task3/task3.c)

### [Текстовий файл](task3/task3_text.txt)

### Пояснення

Ця програма реалізує просту версію утиліти `grep`. Вона приймає два аргументи: слово для пошуку та ім’я файлу.

Програма відкриває файл для читання і построково зчитує його вміст. Для кожного рядка перевіряє, чи містить він задане слово за допомогою `strstr()`. Якщо так — рядок виводиться на екран. Таким чином, програма друкує всі рядки файлу, у яких зустрічається задане слово.

### Результат запуску програми

![](task3/task3.png)

# Завдання 4

## Умова

Напишіть програму, яка виводить список файлів, заданих у вигляді аргументів, з зупинкою кожні 20 рядків, доки не буде натиснута клавіша (спрощена версія утиліти more в UNIX).

## Виконання

### [Код програми](task4/task4.c) 

### Пояснення

Ця програма реалізує спрощену версію утиліти `more`. Вона приймає імена файлів як аргументи і послідовно виводить їх вміст.

Для кожного файлу програма відкриває його і виводить рядки на екран. Після виведення кожних 20 рядків очікує натискання клавіші `Enter`, щоб дати користувачу час прочитати інформацію.

Після закінчення файлу програма переходить до наступного, виводячи заголовок із назвою файлу. Якщо файл відкрити не вдається — виводить повідомлення про помилку і переходить до наступного.

### Результат запуску програми

![](task4/task4_1.png)

![](task4/task4_2.png)

![](task4/task4_3.png)

# Завдання 5

## Умова

Напишіть програму, яка перелічує всі файли в поточному каталозі та всі файли в підкаталогах.

## Виконання

### [Код програми](task5/task5.c) 

### Пояснення

Програма рекурсивно перелічує всі файли та каталоги у поточному каталозі і його підкаталогах.
Вона відкриває заданий каталог, перебирає всі його записи, пропускає `.` і `..`, друкує повний шлях до кожного файлу або каталогу.
Якщо поточний запис — каталог, програма рекурсивно викликає себе для обходу цього підкаталогу.
Таким чином відбувається повний обхід дерева каталогів з виводом усіх файлів та папок.

### Результат запуску програми

![](task5/task5.png)

# Завдання 6

## Умова

 Напишіть програму, яка перелічує лише підкаталоги у алфавітному порядку.

## Виконання

### [Код програми](task6/task6.c) 

### Пояснення

Програма виводить список усіх підкаталогів поточного каталогу в алфавітному порядку.
Вона відкриває каталог, обходить усі записи, пропускаючи `.` та `...` Для кожного запису перевіряє, чи є він каталогом за допомогою `stat()`. Якщо так — зберігає його ім’я в масив рядків.
Після обходу каталогу всі імена підкаталогів сортуються функцією `qsort()` за алфавітом. Потім програма виводить кожен каталог із додаванням символу `/` і звільняє виділену пам’ять.

### Результат запуску програми

![](task6/task6.png)

# Завдання 7

## Умова

Напишіть програму, яка показує користувачу всі його/її вихідні програми на C, а потім в інтерактивному режимі запитує, чи потрібно надати іншим дозвіл на читання (read permission); у разі ствердної відповіді — такий дозвіл повинен бути наданий.

## Виконання

### [Код програми](task7/task7.c) 

### Пояснення

Програма знаходить у поточному каталозі всі виконувані файли, створені поточним користувачем (мають дозвіл на виконання для власника та належать йому).
Для кожного такого файлу вона виводить його ім’я і запитує користувача, чи хоче він надати іншим користувачам дозвіл на читання (o+r). Якщо користувач відповідає «так» (y/Y), програма змінює права файлу, додаючи цей дозвіл.
Програма використовує `opendir()` і `readdir()` для отримання списку файлів, `stat()` — щоб отримати інформацію про права і власника, а `chmod()` — для зміни прав доступу.
Таким чином, користувач має зручний інтерфейс для швидкого надання права читання іншим користувачам чи іншим програмам.

### Результат запуску програми

![](task7/task7.png)

# Завдання 8

## Умова

Напишіть програму, яка надає користувачу можливість видалити будь-який або всі файли у поточному робочому каталозі. Має з’являтися ім’я файлу з запитом, чи слід його видалити.

## Виконання

### [Код програми](task8/task8.c) 

### Пояснення

Ця програма сканує поточний каталог і послідовно виводить імена всіх звичайних файлів. Для кожного файлу користувачу пропонується вибір:

- Видалити файл (ввести y або Y),

- Пропустити файл (будь-який інший символ, крім зазначених),

- Видалити всі файли без подальших запитів (ввести a або A),

- Вийти з програми (ввести q або Q).

Якщо користувач обирає видалити файл, він буде одразу видалений за допомогою функції `remove()`. Якщо вибрано a, то всі наступні файли видаляються автоматично без запиту. Таким чином, програма дає гнучкий спосіб видалення файлів із підтвердженням або масово, з можливістю припинити роботу в будь-який момент.

### Результат запуску програми

![](task8/task8.png)

# Завдання 9

## Умова

Напишіть програму на C, яка вимірює час виконання фрагмента коду в мілісекундах.

## Виконання

### [Код програми](task9/task9.c) 

### Пояснення

Програма на C використовує функцію `gettimeofday` для отримання поточного часу з точністю до мікросекунд, а потім конвертує його в мілісекунди. В `main` вона вимірює час перед та після виконання певного фрагмента коду (тут — пустий цикл з великою кількістю ітерацій). Різниця між кінцевим і початковим часом показує, скільки мілісекунд виконувалася ця частина програми.

### Результат запуску програми

![](task9/task9.png)

# Завдання 10

## Умова

Напишіть програму мовою C для створення послідовності випадкових чисел з плаваючою комою у діапазонах:
 (a) від 0.0 до 1.0
 (b) від 0.0 до n, де n — будь-яке дійсне число з плаваючою точкою.
Початкове значення генератора випадкових чисел має бути встановлене так, щоб гарантувати унікальну послідовність.
Примітка: використання прапорця -Wall під час компіляції є обов’язковим.


## Виконання

### [Код програми](task10/task10.c) 

### Пояснення

Програма запускається з прапорцем `-Wall`. При запуску вона генерує послідовність випадкових чисел з плаваючою комою у двох діапазонах. Спочатку вона створює 10 випадкових чисел у проміжку від 0.0 до 1.0, використовуючи функцію `rand()` та нормалізуючи її значення на `RAND_MAX`. Потім користувач вводить верхню межу діапазону `n` (дійсне число більше за 0), і програма генерує 10 випадкових чисел у діапазоні від 0.0 до `n`. Для гарантії унікальності послідовності випадкових чисел генератор ініціалізується поточним часом за допомогою `srand(time(NULL))`. Програма також перевіряє коректність введеного числа.

### Результат запуску програми

![](task10/task10.png)

# Завдання 11 (варіант 20)

## Умова

Реалізуйте обмежувач використання CPU для вибраного процесу без використання nice, cgroups або taskset.

## Виконання

### [Код основної програми](task11_20/task11_20.c)

### [Код програми для навантаження CPU](task11_20/task11_20_cpu_hog.c)

### Пояснення

Програма реалізує обмежувач завантаження CPU для процесу з заданим `PID` без використання стандартних інструментів (`nice`, `cgroups`, `taskset`). Основна ідея полягає у циклічному призупиненні та відновленні процесу за допомогою сигналів `SIGSTOP` і `SIGCONT`.

Спочатку програма приймає `PID` процесу, який потрібно обмежити, через аргументи командного рядка. Якщо аргументів недостатньо або `PID` некоректний, програма виводить повідомлення про помилку і завершує роботу.

Далі вона обчислює тривалість активної роботи процесу (`active_time`) і час, протягом якого процес буде призупинений (`sleep_time`), виходячи з відсотка бажаного завантаження CPU (у прикладі 20%) і фіксованого циклу в 1000 мілісекунд.

В основному циклі програма послідовно відправляє сигнал `SIGCONT`, що розблокує виконання процесу, після чого затримується на `active_time` мілісекунд, дозволяючи процесу працювати. Потім посилає сигнал `SIGSTOP`, який призупиняє виконання процесу, і знову затримується на `sleep_time` мілісекунд.

Цей цикл повторюється нескінченно, підтримуючи обмежене використання CPU процесом приблизно на заданому рівні. Завдяки такому підходу можна контролювати навантаження на процесор без зміни пріоритетів чи додаткових системних засобів.

Для тестування обмежувача написана проста програма-навантажувач, яка в нескінченному циклі збільшує лічильник, повністю завантажуючи CPU. Таким чином можна спостерігати ефективність обмеження через призупинення/відновлення її виконання.

Для запуску програми навантажувача у фоновому режимі необхідно використати

```bash
./task11_20_cpu_hog &    # запуск у фонофому режимі
echo $!                  # отримання PID процесу
```
після чого ми запускаємо основну програму.

Примітка: ми одразу отримуємо PID процесу щоб по завершенню роботи основної програми (комбінація `Ctrl+C`) ми могли одразу прописати команду для зупинки фонового процесу `kill хPIDх`, де замість `хPIDх` ви вводите PID процесу. 


### Результат запуску програми

![](task11_20/task11_20.png)

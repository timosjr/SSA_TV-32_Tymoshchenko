# Завдання 1

## Умова

Чи може виклик count = write(fd, buffer, nbytes); повернути в змінній count значення, відмінне від nbytes? Якщо так, то чому? Наведіть робочий приклад програми, яка демонструє вашу відповідь.

## Виконання

### [Код програми](task1/task1.c) 

### Пояснення

Так, виклик `count = write(fd, buffer, nbytes);` може повернути значення, відмінне від nbytes. Це означає, що запис було виконано лише частково — не вся кількість байтів була фактично передана.

У цій програмі демонструється така ситуація за допомогою неблокуючого каналу (pipe):

Програма створює канал (pipe) і встановлює його кінець для запису в неблокуючий режим за допомогою `fcntl()`. Далі виділяється буфер на 256 КБ і заповнюється символами 'A'. При цьому інший кінець каналу, з якого треба було б зчитувати дані, залишається без обробки, тож буфер каналу поступово заповнюється.

У неблокуючому режимі, коли буфер каналу заповнено, функція `write()` не чекає, поки з'явиться місце — вона повертає одразу, записавши стільки байтів, скільки змогла (іноді навіть 0), або ж взагалі повертає помилку (-1), якщо не вдалося записати нічого. Таким чином, значення `written` буде менше ніж `buffer_size` — саме це демонструє програма.

У таких випадках треба обробляти часткові записи, зазвичай повторюючи `write()` у циклі, допоки не буде записано все.

### Результат запуску програми

![](task1/task1.png)

# Завдання 2

## Умова

Є файл, дескриптор якого — fd. Файл містить таку послідовність байтів: 4, 5, 2, 2, 3, 3, 7, 9, 1, 5. У програмі виконується наступна послідовність системних викликів:
lseek(fd, 3, SEEK_SET);
read(fd, &buffer, 4);
де виклик lseek переміщує покажчик на третій байт файлу. Що буде містити буфер після завершення виклику read? Наведіть робочий приклад програми, яка демонструє вашу відповідь.


## Виконання

### [Код програми](task2/task2.c) 

### Пояснення

-------------------------------------------

### Результат запуску програми

![](task2/task2.png)

# Завдання 3

## Умова

Бібліотечна функція qsort призначена для сортування даних будь-якого типу. Для її роботи необхідно підготувати функцію порівняння, яка викликається з qsort кожного разу, коли потрібно порівняти два значення.
Оскільки значення можуть мати будь-який тип, у функцію порівняння передаються два вказівники типу void* на елементи, що порівнюються.
Напишіть програму, яка досліджує, які вхідні дані є найгіршими для алгоритму швидкого сортування. Спробуйте знайти кілька масивів даних, які змушують qsort працювати якнайповільніше. Автоматизуйте процес експериментування так, щоб підбір і аналіз вхідних даних виконувалися самостійно.

Придумайте і реалізуйте набір тестів для перевірки правильності функції qsort.


## Виконання

### [Код програми](task3/task3.c) 

### Пояснення

--------------------------------

### Результат запуску програми

![](task3/task3.png)

# Завдання 4

## Умова

Виконайте наступну програму на мові програмування С:
int main() {
  int pid;
  pid = fork();
  printf("%d\n", pid);
}
Завершіть цю програму. Припускаючи, що виклик fork() був успішним, яким може бути результат виконання цієї програми?

## Виконання

### [Код програми](task4/task4.c) 

### Пояснення

-------------------------------------------------------

### Результат запуску програми

![](task4/task4_1.png)

![](task4/task4_2.png)

# Завдання 5 (варіант 20)

## Умова

Напишіть програму, яка демонструє неочевидну поведінку при відкритті одного файлу кілька разів з різними прапорами.

## Виконання

### [Код програми](task5_20/task5_20.c) 

### Пояснення

--------------------------------------------------

### Результат запуску програми

![](task5_20/task5_20.png)

### Фінальний файл

![](task5_20/task5_20_file.png)
